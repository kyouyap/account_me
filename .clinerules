## 重要

ユーザーはRooよりプログラミングが得意ですが、時短のためにRooにコーディングを依頼しています。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考えます。

私は GitHub
から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速いでしょう。テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書きます。

反面、現在のコンテキストに応じた処理は苦手です。コンテキストが不明瞭な時は、ユーザーに確認します。

## 作業開始準備

`git status` で現在の git のコンテキストを確認します。
もし指示された内容と無関係な変更が多い場合、現在の変更からユーザーに別のタスクとして開始するように提案してください。

無視するように言われた場合は、そのまま続行します。



# コーディングプラクティス

## 原則

### 関数型アプローチ (FP)
- **純粋関数を優先:** 外部状態に依存しない関数を作る  
- **不変データ構造を使用:** 変更不可なオブジェクト（例: `@dataclass(frozen=True)`）を活用する  
- **副作用を分離:** I/O や外部通信は関数の境界に押し出す  
- **型安全性を確保:** 型ヒントをフル活用し、`mypy --strict` を CI で必須にする  

### ドメイン駆動設計 (DDD)
- **値オブジェクトとエンティティを区別:** 不変な値オブジェクト／ID で同一性を判断するエンティティ  
- **集約で整合性を保証:** 一貫性が必要な要素は 1 つの集約ルートに閉じ込める  
- **リポジトリでデータアクセスを抽象化:** DB・API 呼び出しを隠蔽しテスタビリティ向上  
- **境界付けられたコンテキスト:** ドメインごとに独立したモジュールへ分割  

### テスト駆動開発 (TDD)
- **Red-Green-Refactor サイクル:** 失敗するテスト → 実装 → リファクタ  
- **テスト＝仕様:** テストがシステムの期待振る舞いを語る  
- **小さな単位で反復:** 1 つの振る舞いにつき 1 つのテスト  
- **常にリファクタ:** 重複排除と設計改善を継続  

---

## 1. コードスタイル

| ツール | 設定／運用 |
|-------|-----------|
| **black** | 行長 88、`--target-version py313` |
| **ruff**  | flake8 + isort + pep8-naming を統合。CI で必須 |
| **pre-commit** | `pre-commit run --all-files` を Git hook で強制 |

> *議論はツールに委ね、レビューでは本質（設計・命名）に集中する。*

---

## 2. 型ヒント & 静的解析

- **PEP 695** の *新ジェネリック構文* `class Box[T]: ...` が使用可能
- `from __future__ import annotations` は常に最上部に書く  
- エイリアス宣言例  
  ```python
  type JSON = dict[str, "JSON | str | int | bool | None"]
  ```  
- **mypy 設定**  
  ```ini
  [mypy]
  python_version = 3.13
  strict = True
  incremental = True
  warn_unused_ignores = True
  ```

---

## 3. Docstring 規約（Google Style）

```python
def fetch_user(user_id: int) -> User:
    """Retrieve a user domain model.

    Args:
        user_id: Unique identifier.

    Returns:
        Retrieved user.

    Raises:
        UserNotFoundError: If the user does not exist.
    """
```

1 行サマリ → 詳細 → Args → Returns → Raises → Examples の順序を厳守。

---

## 4. ディレクトリ構成（DDD + src レイアウト）

```
project/
├── src/
│   ├── domain/         # エンティティ・値オブジェクト
│   ├── app/            # アプリケーションサービス
│   ├── infra/          # DB / 外部 API (Adapter)
│   ├── presentation/   # CLI / FastAPI / Lambda 等 I/O 層
│   └── settings.py     # Pydantic-Settings
└── tests/
```

---

## 5. 依存性の注入（DI）

```python
class UserRepo(Protocol):
    def save(self, user: User) -> None: ...

class SqlUserRepo(UserRepo):
    ...

class UserService:
    def __init__(self, repo: UserRepo) -> None:
        self._repo = repo
```

- **コンストラクタインジェクション** を第一選択  
- `dependency-injector` などのコンテナを用い、テストでは Stub に差し替え  

---

## 6. エラー処理

- ビジネスエラーは独自例外 (`class DomainError(Exception): ...`)  
- `try / except / else / finally` をフル活用しロールバックを保証  
- 例外メッセージは **検索可能なキーワード＋変数値** を含める  

---

## 7. ロギング

- **structlog + 標準 logging** で JSON 出力  
- レベル基準  
  - DEBUG : 変数・ループ内部  
  - INFO  : 正常フロー  
  - WARNING : リトライ可能  
  - ERROR : 失敗・アラート  

---

## 8. テスト指針

- **pytest ≥ 8**, **pytest-asyncio**  
- **Arrange-Act-Assert** を徹底  
- カバレッジ閾値: 行 95 % / 分岐 90 %（`coverage.py`）  
- テストダブル: `unittest.mock`, `pytest-mock`, `factory-boy`  

---

## 9. デザインパターン実装例

### Strategy

```python
from typing import Protocol

class Discount(Protocol):
    def __call__(self, price: float) -> float: ...

def no_discount(p: float) -> float: return p
def seasonal_discount(p: float) -> float: return p * 0.9

class PriceCalculator:
    def __init__(self, strategy: Discount = no_discount) -> None:
        self._strategy = strategy
    def calc(self, price: float) -> float: return self._strategy(price)
```

### Adapter

```python
class PaymentSDK:  # 外部ライブラリ
    def send(self, payload: dict[str, str]) -> None: ...

class PaymentPort(Protocol):
    def pay(self, amount: int) -> None: ...

class PaymentAdapter(PaymentPort):
    def __init__(self, sdk: PaymentSDK) -> None:
        self._sdk = sdk
    def pay(self, amount: int) -> None:
        self._sdk.send({"amount": str(amount)})
```

### Factory Method

```python
from abc import ABC, abstractmethod

class Exporter(ABC):
    @abstractmethod
    def export(self, data: str) -> None: ...

class JsonExporter(Exporter):
    def export(self, data: str) -> None: print(f"Exporting {data} to JSON")

class CsvExporter(Exporter):
    def export(self, data: str) -> None: print(f"Exporting {data} to CSV")

class ExporterFactory(ABC):
    @abstractmethod
    def create_exporter(self) -> Exporter: ...

class JsonExporterFactory(ExporterFactory):
    def create_exporter(self) -> Exporter: return JsonExporter()

class CsvExporterFactory(ExporterFactory):
    def create_exporter(self) -> Exporter: return CsvExporter()
```

### Observer

```python
from typing import Protocol, List

class Observer(Protocol):
    def update(self, message: str) -> None: ...

class Subject:
    def __init__(self) -> None:
        self._observers: List[Observer] = []

    def attach(self, observer: Observer) -> None:
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer: Observer) -> None:
        self._observers.remove(observer)

    def notify(self, message: str) -> None:
        for observer in self._observers:
            observer.update(message)

class EmailNotifier(Observer):
    def update(self, message: str) -> None:
        print(f"Sending email notification: {message}")
```

### Decorator

```python
import time
from typing import Callable, Any

def timing_decorator(func: Callable[..., Any]) -> Callable[..., Any]:
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds")
        return result
    return wrapper

@timing_decorator
def process_data(data: list[int]) -> int:
    time.sleep(0.1) # Simulate work
    return sum(data)
```

---

## 10. 非同期 & 並行処理

| 処理 | 推奨手法 |
|------|-----------|
| I/O バウンド | `asyncio`, `aiohttp`, `asyncpg` |
| CPU バウンド | `concurrent.futures.ProcessPoolExecutor` |
| キャンセル伝搬 | `except asyncio.CancelledError:` で握りつぶさない |

---

## 11. パフォーマンス最適化

- **PEP 703** : GIL なしビルド (実験的) によりスレッド並列化が可能 
- **PEP 744** : JIT 基盤 (試験的) – ボトルネック関数の測定を優先し安易に ON にしない 
- `functools.cache`, `slots=True` dataclass, `heapq`, `bisect` 等を駆使し O 計算量を意識  

---

## 12. セキュリティ

1. **Secrets 管理**: `.env`, HashiCorp Vault, GCP Secret Manager などを経由  
2. **依存脆弱性スキャン**: `pip-audit`, `safety` を CI に  
3. **入力検証**: `pydantic` v3 の `model_validate`  
4. **Web**: SQLi・XSS・CSRF を OWASP ASVS でチェック  




# Python のベストプラクティス

---

## 目次

1. 全体方針  
2. 実装の選択基準  
3. コードスタイル & フォーマッタ  
4. 型ヒント & 静的解析  
5. Docstring 規約（Google Style）  
6. モジュール / パッケージ構成  
7. 依存性の注入（DI）  
8. エラー処理 & 例外設計  
9. ロギング  
10. テスト指針  
11. デザインパターン実装例  
12. 非同期 & 並行処理  
13. パフォーマンス最適化  
14. セキュリティ / 安全なコード  
15. 参考資料

---

## 1. 全体方針

| 目的 | 具体策 |
|------|--------|
| **読みやすさ最優先** | *Self-Documenting Code* を目指す。意味のある変数名・関数名、重複排除（DRY）。 |
| **自動整形の徹底** | `black`, `ruff`, `isort` を CI で強制。人間同士のスタイル議論をゼロにする。 |
| **型安全** | 100 %型ヒント＋`mypy --strict`。曖昧さを排除し、保守コストを下げる。 |
| **小さく作り、大きく育てる** | 小さい PR・小さい関数でフィードバックループを短縮。 |
| **実行環境の統一** | `pyproject.toml` でバージョン固定。Docker / dev container 推奨。 |

---

## 2. 実装の選択基準

> JavaScript 規約のテイストを踏襲したシンプルさで整理📝

| 選択肢 | 使う場面 | 主なメリット |
|--------|---------|-------------|
| **関数** | - 単純な計算・純粋関数<br>- 内部状態を保持しない | テスト容易、依存最小、読解負荷が低い |
| **クラス** | - 内部状態を管理したい<br>- リソースのライフサイクルが必要（DBコネクタなど） | 状態と振る舞いをまとめて表現 |
| **データクラス (`@dataclass`)** | - 不変データレコード<br>- 値オブジェクト | ボイラープレート削減、比較/排序が楽 |
| **Enum** | - 限定された定数集合 | マジックナンバー排除、型安全 |
| **Protocol / 抽象基底クラス** | - 実装の交換が前提<br>- テストダブル注入 | DI と相性良し、LSP 準拠 |
| **Adapter** | - 外部 API / DB / SDK の抽象化 | テスト容易、実装差し替え |
| **モジュール単位のシングルトン** | - 設定値やログなど一意リソース | グローバル変数より安全 |
| **スクリプト (`if __name__ == "__main__":`)** | - ワンショット実行ツール | CLI インタフェースを簡易に用意 |

---

## 3. コードスタイル & フォーマッタ

| ツール | ルール |
|-------|--------|
| **black** | 行長 88 桁、--target-version py313 |
| **ruff** | Pylint, flake8, isort, pep8-naming 等を統合。エラーは CI ブロッカー。 |
| **pre-commit** | `pre-commit run --all-files` を Git hook に。 |
| **PEP 8 準拠** | black が自動担保。例外：行長を越える Google style docstring の `Args:` セクションは許可。 |

---

## 4. 型ヒント & 静的解析

1. **原則すべての公開 API に型を付与**。  
2. **`from __future__ import annotations`** を常に先頭に。  
3. **3.13 の機能**  
   - PEP 695: `class Box[T]: ...` の新ジェネリック構文  
   - `Self` 型 & `typing.Sealed`（シールドクラス）  
4. **型エイリアス宣言**  
   ```python
   type JSON = dict[str, "JSON | str | int | bool | None"]  # PEP695
   ```
5. **mypy 設定（抜粋）**
   ```ini
   [mypy]
   python_version = 3.13
   strict = True
   warn_unused_configs = True
   ```

---

## 5. Docstring 規約（Google Style）

```python
def fetch_user(user_id: int) -> User:
    ```python
        """単一のユーザーオブジェクトを取得します。

        Args:
            user_id: ユーザーの一意な識別子。

        Returns:
            User: 取得されたユーザーのドメインモデル。

        Raises:
            UserNotFoundError: ユーザーが存在しない場合。
        """
    ```
```

- セクション順序: **Summary → Args → Returns → Raises → Examples**  
- 1行サマリは動詞から。  
- **例** には `>>>` を使い doctest 可能に。

---

## 6. モジュール / パッケージ構成

```
project/
├── src/
│   ├── app/            # アプリケーションサービス
│   ├── domain/         # エンティティ & 値オブジェクト
│   ├── infra/          # DB / API 実装 (Adapter)
│   ├── presentation/   # CLI / Web Handler
│   └── settings.py     # Pydantic ベース設定
├── tests/
│   └── ...
├── pyproject.toml
└── README.md
```

- **`src/` レイアウト** 推奨。  
- ドメイン駆動設計 (DDD) に合わせて `domain`, `app`, `infra`, `presentation` を分離。  

---

## 7. 依存性の注入（DI）

| 指針 | 例 |
|------|----|
| **コンストラクタインジェクションが第一候補** | ```python class UserService: def __init__(self, repo: UserRepo): ...``` |
| **ファクトリ / Provider パターンを組み合わせる** | `providers.Factory(UserService)` (dependency-injector ライブラリなど) |
| **設定 & 環境変数は Pydantic-Settings で吸収** | `settings.db.url` を注入 |
| **テストでは Stub / Mock 実装に差し替え** | Protocol をキーに DI コンテナでバインド切替 |

---

## 8. エラー処理 & 例外設計

1. **ビジネスエラーは独自例外クラス**（`class DomainError(Exception): ...`）  
2. **Python 組み込み例外を安易に握りつぶさない**  
3. **`try / except / else / finally` ブロックをフル活用**  
4. **例外メッセージはログ・モニタリングで検索可能なキーワードを含める**

---

## 9. ロギング

- `structlog` + 標準 `logging` で JSON 出力。  
- **ログレベル基準**  
  - DEBUG: 変数値  
  - INFO: 正常系ステップ  
  - WARNING: リトライ可能／軽微エラー  
  - ERROR: 失敗 (アラート)  
- **ContextVar** でトレース ID を伝搬。

---

## 10. テスト指針

| 項目 | 推奨 |
|------|------|
| **フレームワーク** | `pytest>=8`, `pytest-asyncio` |
| **AAA パターン** | *Arrange-Act-Assert* を厳守。 |
| **カバレッジ閾値** | 行 95 % / 分岐 90 % 以上を CI で必須。 |
| **テストダブル** | `unittest.mock`, `pytest-mock`, `factory-boy` |
| **フィクスチャ階層** | `conftest.py` をルートに共通化。 |

---

## 11. デザインパターン実装例

> **型ヒント＋Google docstring 付きのミニ実装。**

### 11.1 Strategy

```python
from collections.abc import Callable
from typing import Protocol

class DiscountStrategy(Protocol):
    """Strategy インタフェース。"""

    def __call__(self, price: float) -> float: ...

def no_discount(price: float) -> float:  # 関数も Strategy に
    return price

def seasonal_discount(price: float) -> float:
    return price * 0.9

class PriceCalculator:
    """価格計算クラス (Context)。"""

    def __init__(self, strategy: DiscountStrategy = no_discount) -> None:
        self._strategy = strategy

    def calc(self, price: float) -> float:
        """選択された Strategy で価格を算出。"""
        return self._strategy(price)
```

### 11.2 Adapter

```python
class PaymentGateway:
    """外部 SDK (既存)."""
    def send(self, payload: dict[str, str]) -> None: ...

class PaymentPort(Protocol):
    def pay(self, amount: int) -> None: ...

class PaymentAdapter:
    """SDK をラップし抽象ポートを実装。"""

    def __init__(self, sdk: PaymentGateway) -> None:
        self._sdk = sdk

    def pay(self, amount: int) -> None:
        self._sdk.send({"amount": str(amount)})
```

*Singleton, Factory, Observer, Command* などは付録にコード例を配置（省略）。

---

## 12. 非同期 & 並行処理

1. **`asyncio` を優先しスレッド乱用禁止**  
2. **I/O バウンド処理** → `asyncio`, CPU バウンド → `concurrent.futures.ProcessPoolExecutor`  
3. **Cancellation 伝搬** を忘れず `try/except asyncio.CancelledError`  
4. **非同期コンテキストマネージャ** (`async with`) で接続を安全に管理。

---

## 13. パフォーマンス最適化

| レイヤ | 施策 |
|-------|-----|
| **アルゴリズム** | Big-O を意識。辞書・集合を活用する。 |
| **I/O** | `aiohttp`, `asyncpg` など非同期ライブラリ。 |
| **データ構造** | `array`, `deque`, `bisect`, `heapq` | 
| **メモリ** | `slots=True` dataclass、`functools.cache` で重複計算削減。 |
| **コンパイル** | `python -OO -m py_compile` や Cython / mypyc は最後の手段。 |

---

## 14. セキュリティ / 安全なコード

- **依存ライブラリ脆弱性スキャン**: `pip-audit`, `safety`.  
- **Secrets 管理**: 環境変数 & Secret Manager、ハードコード禁止。  
- **入力値バリデーション**: Pydantic v3 の `model_validate`。  
- **Web 開発**: インジェクション・XSS・CSRF 対策、`werkzeug.security` や OWASP ASVS を参照。  
- **署名付き型アノテーション** で意図しないミューテーションを防ぐ。

---

### 使い方のヒント

1. 本ドキュメントを **社内 Wiki / README** にそのまま貼り付けても OK。  
2. プロジェクト固有の規定（命名プリフィックス、CI /CD など）は追記。  
3. 運用しながら Pull Request で改善案を随時取り込むことで「生きた規約」に。  



# テスト駆動開発 (TDD) の基本

## 基本概念

テスト駆動開発（TDD）は、以下のサイクルで進める開発手法です：

1. **Red:**  
   まず、失敗するテストケースを書いて、実装すべき仕様を明確にします。
2. **Green:**  
   テストが通るように、最小限の実装を行います。
3. **Refactor:**  
   コードをリファクタリングして改善し、読みやすさや保守性を向上させます。

## 重要な考え方

- **テストは仕様である:**  
  テストコードは、実装すべき仕様そのものとして扱います。テストケースを見るだけで、どのような挙動が求められているかが分かるようにします。

- **Assert-Act-Arrange の順序で考える:**  
  テストコードの記述順序を次のように意識してください：
  1. **Assert（期待結果）:**  
     最初に期待する結果を定義します。
  2. **Act（操作）:**  
     次にテスト対象の処理を実行します。
  3. **Arrange（準備）:**  
     最後にテスト環境のセットアップや必要な準備コードを記述します。

  ※ 実際の実行順序は Arrange → Act → Assert ですが、実装の際は期待結果から始めることで、目的を明確にしてコードを書き進められます。

- **テスト名は「状況→操作→結果」の形式で記述:**  
  例：  
  「有効なトークンの場合にユーザー情報を取得すると成功すること」  
  「無効なトークンの場合にエラーが返されること」

## リファクタリングフェーズの重要ツール

テストが通った後のリファクタリングフェーズでは、以下のツールを活用してください：

1. **静的解析・型チェック:**
   - `mypy .`  
     型チェックを行い、型安全性を確認します。
   - `ruff .`
     コード品質とスタイルのチェックを実施します。

2. **デッドコード検出・削除:**
   - [vulture](https://pypi.org/project/vulture/) を使用して、未使用の関数やエクスポートを定期的に検出し、必要に応じて削除します。

3. **コードカバレッジ測定:**
   - `pytest --cov=.` を使用してテストカバレッジを計測し、coverage.py でレポートを確認します。
     ```bash
     pytest --cov=.  # テストを実行しカバレッジレポートを生成
     coverage report  # カバレッジの概要を表示
     ```
   
4. **Git によるバージョン管理:**
   - 各フェーズ（テスト作成→実装→リファクタリング）の完了時に、変更内容を Git にコミットします。  
   - タスク完了時にユーザーに確認してから、以下のコマンドでコミットを実行します：
     ```bash
     git status  # 変更状態を確認
     git add <関連ファイル>
     git commit -m "<適切なコミットメッセージ>"
     ```
   - コミットメッセージは以下のプレフィックスを使い分けます：
     - `test:` - テストの追加・修正
     - `feat:` - 新機能の実装
     - `fix:` - バグ修正
     - `refactor:` - リファクタリング
     - `docs:` - ドキュメントの更新
     - `chore:` - ビルドプロセスやツールの変更

このプロジェクトには以下のモードが定義されています:
- python-tdd Python:Module at .cline/roomodes/python-tdd.md
- python-module Python:Module at .cline/roomodes/python-module.md
- python-refactor Deno:Refactor at .cline/roomodes/python-refactor.md
- uv-script uv-script Python at .cline/roomodes/uv-script.md